"use server"; // Mark this file for server-side execution only

import { z } from "zod"; // For data validation
import { revalidatePath } from "next/cache"; // For cache invalidation after mutations
import { Prisma } from "@prisma/client"; // Import Prisma types for error handling, etc.
import bcrypt from 'bcryptjs'; // Import bcrypt for hashing passwords

import prisma from "@/lib/prisma"; // Import the configured Prisma Client instance
import { getCurrentUserSession } from "@/lib/auth"; // Import helper to get current user session
import { Role } from "@prisma/client"; // Import the Role enum generated by Prisma

// --- Define ActionResult Type Locally ---
// Standardized return type for all actions in this file
type ActionResult = {
  success: boolean; // Indicates if the action was successful
  message?: string; // Provides a user-friendly message (success or error)
  centerId?: string; // Optionally return the ID of the affected center
  userId?: string;   // Optionally return the ID of the affected user
};
// --- ---


// --- Validation Schemas ---

// Schema for creating a new center
const CreateCenterSchema = z.object({
  centerName: z.string().min(3, "Name must be at least 3 characters.").max(100, "Name cannot exceed 100 characters."),
  coordinatorId: z.string().cuid("Invalid coordinator ID format."),
});

// Schema for updating center details (currently just name)
const UpdateCenterSchema = z.object({
    centerId: z.string().cuid("Invalid center ID format."),
    name: z.string().min(3, "Name must be at least 3 characters.").max(100, "Name cannot exceed 100 characters."),
    // Add other editable center fields here in the future if needed
});

// Schema for deleting a center
const DeleteCenterSchema = z.object({
    centerId: z.string().cuid("Invalid center ID format."),
});

// Schema for assigning/unassigning a lecturer to/from a center
const ManageLecturerSchema = z.object({
    centerId: z.string().cuid("Invalid center ID."),
    lecturerId: z.string().cuid("Invalid lecturer ID."),
});

// Schema for changing the coordinator of a center
const ChangeCoordinatorSchema = z.object({
    centerId: z.string().cuid("Invalid center ID."),
    newCoordinatorId: z.string().cuid("Invalid new coordinator ID."),
});

// Schema for creating a new user (Lecturer or Coordinator) by Registry
const CreateUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters.").max(100).optional(),
  email: z.string().email("Invalid email format."),
  password: z.string().min(8, "Password must be at least 8 characters."),
  // Ensure only LECTURER or COORDINATOR can be selected
  role: z.nativeEnum(Role).refine(role => role === Role.LECTURER || role === Role.COORDINATOR, {
      message: "Role must be either Coordinator or Lecturer."
  }),
});

// Schema for editing user details (currently just name)
const EditUserSchema = z.object({
    userId: z.string().cuid("Invalid user ID format."),
    name: z.string().min(2, "Name must be at least 2 characters.").max(100).optional(),
    // Add other editable fields like email or role change logic here if needed (carefully!)
});

// Schema for deleting a user
const DeleteUserSchema = z.object({
    userId: z.string().cuid("Invalid user ID format."),
});


// --- Create Center Server Action ---
/**
 * Creates a new center and assigns a coordinator.
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching CreateCenterSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function createCenter(values: unknown): Promise<ActionResult> {
  const session = getCurrentUserSession();
  if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

  const validatedFields = CreateCenterSchema.safeParse(values);
  if (!validatedFields.success) {
      const firstError = Object.values(validatedFields.error.flatten().fieldErrors)[0]?.[0];
      return { success: false, message: firstError || "Invalid data provided." };
  }
  const { centerName, coordinatorId } = validatedFields.data;

  console.log(`Registry Action: Create Center "${centerName}" with coord ${coordinatorId}`);
  try {
    // Verify coordinator exists, has correct role, and is available
    const coordinator = await prisma.user.findUnique({ where: { id: coordinatorId, role: Role.COORDINATOR }, include: { coordinatedCenter: true } });
    if (!coordinator) return { success: false, message: "Coordinator not found or invalid role." };
    if (coordinator.coordinatedCenter) return { success: false, message: "Coordinator already assigned." };

    // Create the center and link the coordinator
    const newCenter = await prisma.center.create({ data: { name: centerName, coordinator: { connect: { id: coordinatorId } } } });
    console.log(`Registry Action: Created Center ${newCenter.id}`);

    // Revalidate relevant paths
    revalidatePath('/registry/centers');
    revalidatePath(`/registry/centers/${newCenter.id}`);

    return { success: true, message: `Center "${newCenter.name}" created.`, centerId: newCenter.id };
  } catch (error) {
    console.error("Create Center Error:", error);
    // Handle unique constraint violation on center name
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') return { success: false, message: `Center name "${centerName}" already exists.` };
    return { success: false, message: "Internal error creating center." };
  }
}


// --- Update Center Server Action ---
/**
 * Updates the details of an existing center (currently only the name).
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching UpdateCenterSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function updateCenter(values: unknown): Promise<ActionResult> {
   const session = getCurrentUserSession();
   if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

   // Validate input data
   const validatedFields = UpdateCenterSchema.safeParse(values);
   if (!validatedFields.success) {
       const firstError = Object.values(validatedFields.error.flatten().fieldErrors)[0]?.[0];
       return { success: false, message: firstError || "Invalid data provided." };
   }
   const { centerId, name } = validatedFields.data; // Extract validated name

   console.log(`Registry Action: Update Center ${centerId} name to "${name}"`);
   try {
        // Perform the update
        const updatedCenter = await prisma.center.update({
            where: { id: centerId },
            data: { name }, // Update the name field
        });
        console.log(`Registry Action: Updated Center ${centerId}`);

        // Revalidate paths
        revalidatePath('/registry/centers');
        revalidatePath(`/registry/centers/${centerId}`);

        return { success: true, message: `Center name updated to "${updatedCenter.name}".`, centerId: updatedCenter.id };
   } catch (error) {
        console.error("Update Center Error:", error);
        // Handle specific Prisma errors
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            // Unique constraint violation (e.g., duplicate name)
            if (error.code === 'P2002') return { success: false, message: `Center name "${name}" already exists.` };
            // Record to update not found
            if (error.code === 'P2025') return { success: false, message: "Center not found." };
        }
        return { success: false, message: "Internal error updating center." };
   }
}

// --- Delete Center Server Action ---
/**
 * Deletes a center after unassigning its lecturers.
 * Requires coordinator to be unassigned beforehand (relies on DB constraint).
 * Only accessible by users with the REGISTRY role.
 * WARNING: This deletes associated Departments and Claims due to schema cascade rules.
 * @param values - Input data matching DeleteCenterSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function deleteCenter(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    // Validate input
    const validatedFields = DeleteCenterSchema.safeParse(values);
    if (!validatedFields.success) return { success: false, message: "Invalid data." };
    const { centerId } = validatedFields.data;

    console.log(`Registry Action: Delete Center ${centerId}`);

    try {
        // Check if center exists and count lecturers
        const center = await prisma.center.findUnique({
            where: { id: centerId },
            select: { id: true, name: true, _count: { select: { lecturers: true } } }
        });
        if (!center) return { success: false, message: "Center not found." };

        // **Important**: Unassign lecturers BEFORE deleting the center
        if (center._count.lecturers > 0) {
            await prisma.user.updateMany({
                where: { lecturerCenterId: centerId },
                data: { lecturerCenterId: null, departmentId: null }, // Unassign from center and department
            });
            console.log(`Registry Action: Unassigned ${center._count.lecturers} lecturers from Center ${centerId}`);
        }

        // Attempt to delete the center. Prisma will throw P2014 if coordinator is still linked.
        await prisma.center.delete({ where: { id: centerId } });

        console.log(`Registry Action: Deleted Center ${center.name} (${centerId})`);

        // Revalidate paths
        revalidatePath('/registry/centers');
        revalidatePath('/dashboard'); // Stats might change

        return { success: true, message: `Center "${center.name}" deleted successfully.` };

    } catch (error) {
        console.error("Delete Center Error:", error);
         if (error instanceof Prisma.PrismaClientKnownRequestError) {
             // P2014: Relation violation (likely coordinator still linked)
             if (error.code === 'P2014') {
                 return { success: false, message: "Cannot delete center. Please ensure the coordinator is unassigned first." };
             }
             // P2025: Record to delete not found
             if (error.code === 'P2025') {
                 return { success: false, message: "Center not found. It may have already been deleted." };
             }
         }
        return { success: false, message: "Internal error deleting center." };
    }
}


// --- Assign Lecturer to Center Server Action ---
/**
 * Assigns an available lecturer to a specific center.
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching ManageLecturerSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function assignLecturerToCenter(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    const validatedFields = ManageLecturerSchema.safeParse(values);
    if (!validatedFields.success) return { success: false, message: "Invalid data." };
    const { centerId, lecturerId } = validatedFields.data;

    console.log(`Registry Action: Assign Lecturer ${lecturerId} to Center ${centerId}`);
    try {
        // Verify center exists
        const center = await prisma.center.findUnique({ where: { id: centerId }, select: { id: true } });
        if (!center) return { success: false, message: "Center not found." };

        // Verify lecturer exists, has correct role, and is available
        const lecturer = await prisma.user.findUnique({ where: { id: lecturerId }, select: { id: true, role: true, lecturerCenterId: true } });
        if (!lecturer) return { success: false, message: "Lecturer not found." };
        if (lecturer.role !== Role.LECTURER) return { success: false, message: "User is not a Lecturer." };
        if (lecturer.lecturerCenterId) return { success: false, message: "Lecturer already assigned to a center." }; // Assumes 1 center per lecturer

        // Perform assignment
        await prisma.user.update({ where: { id: lecturerId }, data: { lecturerCenterId: centerId } });
        console.log(`Registry Action: Assigned Lecturer ${lecturerId} to Center ${centerId}`);

        // Revalidate paths
        revalidatePath(`/registry/centers/${centerId}/lecturers`);
        revalidatePath(`/registry/centers/${centerId}`);

        return { success: true, message: "Lecturer assigned." };
    } catch (error) {
        console.error("Assign Lecturer Error:", error);
        return { success: false, message: "Internal error assigning lecturer." };
    }
}


// --- Unassign Lecturer from Center Server Action ---
/**
 * Removes a lecturer's assignment from a specific center.
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching ManageLecturerSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function unassignLecturerFromCenter(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    const validatedFields = ManageLecturerSchema.safeParse(values);
    if (!validatedFields.success) return { success: false, message: "Invalid data." };
    const { centerId, lecturerId } = validatedFields.data;

    console.log(`Registry Action: Unassign Lecturer ${lecturerId} from Center ${centerId}`);
    try {
        // Verify lecturer exists and is assigned to this center
        const lecturer = await prisma.user.findUnique({ where: { id: lecturerId }, select: { id: true, lecturerCenterId: true } });
        if (!lecturer) return { success: false, message: "Lecturer not found." };
        if (lecturer.lecturerCenterId !== centerId) return { success: false, message: "Lecturer not assigned to this center." };

        // Perform unassignment
        await prisma.user.update({ where: { id: lecturerId }, data: { lecturerCenterId: null, departmentId: null } }); // Also clear department
        console.log(`Registry Action: Unassigned Lecturer ${lecturerId}`);

        // Revalidate paths
        revalidatePath(`/registry/centers/${centerId}/lecturers`);
        revalidatePath(`/registry/centers/${centerId}`);

        return { success: true, message: "Lecturer removed from center." };
    } catch (error) {
        console.error("Unassign Lecturer Error:", error);
        return { success: false, message: "Internal error removing lecturer." };
    }
}


// --- Change Center Coordinator Server Action ---
/**
 * Changes the coordinator assigned to a specific center.
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching ChangeCoordinatorSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function changeCenterCoordinator(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    const validatedFields = ChangeCoordinatorSchema.safeParse(values);
    if (!validatedFields.success) return { success: false, message: "Invalid data." };
    const { centerId, newCoordinatorId } = validatedFields.data;

    console.log(`Registry Action: Change Coordinator for Center ${centerId} to ${newCoordinatorId}`);
    try {
        // Verify center exists and get current coordinator ID
        const center = await prisma.center.findUnique({ where: { id: centerId }, select: { id: true, coordinatorId: true } });
        if (!center) return { success: false, message: "Center not found." };
        if (center.coordinatorId === newCoordinatorId) return { success: false, message: "User is already the coordinator." };

        // Verify the new coordinator exists, has correct role, and is available
        const newCoordinator = await prisma.user.findUnique({ where: { id: newCoordinatorId }, select: { id: true, role: true, coordinatedCenter: true } });
        if (!newCoordinator) return { success: false, message: "New coordinator not found." };
        if (newCoordinator.role !== Role.COORDINATOR) return { success: false, message: "User is not a Coordinator." };
        if (newCoordinator.coordinatedCenter) return { success: false, message: "Coordinator already assigned elsewhere." };

        // Perform the update on the Center record
        await prisma.center.update({ where: { id: centerId }, data: { coordinatorId: newCoordinatorId } });
        console.log(`Registry Action: Changed Coordinator for Center ${centerId}`);

        // Revalidate relevant paths
        revalidatePath(`/registry/centers/${centerId}/coordinator`);
        revalidatePath(`/registry/centers/${centerId}`);
        revalidatePath('/registry/centers');

        return { success: true, message: "Coordinator updated." };
    } catch (error) {
        console.error("Change Coordinator Error:", error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') return { success: false, message: "Center or Coordinator not found." };
        return { success: false, message: "Internal error changing coordinator." };
    }
}


// --- Create User Server Action ---
/**
 * Creates a new user (Lecturer or Coordinator) by the Registry admin.
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching CreateUserSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function createUser(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    // Validate input data
    const validatedFields = CreateUserSchema.safeParse(values);
    if (!validatedFields.success) {
      const firstError = Object.values(validatedFields.error.flatten().fieldErrors)[0]?.[0];
      return { success: false, message: firstError || "Invalid data." };
    }
    const { name, email, password, role } = validatedFields.data;

    console.log(`Registry Action: Create User ${email} with role ${role}`);
    try {
        // Check if user already exists
        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) return { success: false, message: `Email ${email} already exists.` };

        // Hash the password
        const hashedPassword = await bcrypt.hash(password, 10);

        // Create the user
        const newUser = await prisma.user.create({ data: { email, password: hashedPassword, name: name || null, role } });
        console.log(`Registry Action: Created User ${newUser.id}`);

        // Revalidate users list page
        revalidatePath('/registry/users');

        return { success: true, message: `User ${newUser.email} (${newUser.role}) created.`, userId: newUser.id };
    } catch (error) {
        console.error("Create User Error:", error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') return { success: false, message: `Email ${email} already exists.` };
        return { success: false, message: "Internal error creating user." };
    }
}


// --- Edit User Server Action ---
/**
 * Edits user details (currently only name).
 * Only accessible by users with the REGISTRY role.
 * @param values - Input data matching EditUserSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function editUser(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    // Validate input data
    const validatedFields = EditUserSchema.safeParse(values);
    if (!validatedFields.success) {
        const firstError = Object.values(validatedFields.error.flatten().fieldErrors)[0]?.[0];
        return { success: false, message: firstError || "Invalid data." };
    }
    const { userId, name } = validatedFields.data; // Add other fields like email, role later if needed

    console.log(`Registry Action: Edit User ${userId}`);
    try {
        // Fetch user to ensure they exist before updating
        const user = await prisma.user.findUnique({ where: { id: userId }, select: { id: true } });
        if (!user) return { success: false, message: "User not found." };

        // Perform the update (only name for now)
        await prisma.user.update({
            where: { id: userId },
            data: { name: name || null }, // Update name, allowing it to be nullable
        });

        console.log(`Registry Action: Updated User ${userId}`);

        // Revalidate user list
        revalidatePath('/registry/users');
        // Revalidate specific user detail page if it exists
        // revalidatePath(`/registry/users/${userId}`);

        return { success: true, message: "User details updated.", userId };
    } catch (error) {
        console.error("Edit User Error:", error);
        // Handle potential errors like unique constraint on email if editing email
        return { success: false, message: "Internal error editing user." };
    }
}

// --- Delete User Server Action ---
/**
 * Deletes a user (Lecturer or Coordinator). Prevents deleting self or other Registry admins.
 * Prevents deleting coordinators assigned to centers.
 * Only accessible by users with the REGISTRY role.
 * WARNING: Deleting a lecturer cascades to delete their claims per schema rules.
 * @param values - Input data matching DeleteUserSchema.
 * @returns ActionResult indicating success or failure.
 */
export async function deleteUser(values: unknown): Promise<ActionResult> {
    const session = getCurrentUserSession();
    if (session?.role !== Role.REGISTRY) return { success: false, message: "Unauthorized." };

    // Validate input
    const validatedFields = DeleteUserSchema.safeParse(values);
    if (!validatedFields.success) return { success: false, message: "Invalid data." };
    const { userId } = validatedFields.data;

    // **Safety Check**: Prevent deleting own account
    if (session.userId === userId) {
        return { success: false, message: "Cannot delete your own account." };
    }

    console.log(`Registry Action: Delete User ${userId}`);
    try {
        // Fetch user details to check role and assignments before deleting
        const userToDelete = await prisma.user.findUnique({
            where: { id: userId },
            // Select fields needed for safety checks
            select: { id: true, role: true, coordinatedCenter: { select: { name: true } }, email: true },
        });

        // Check if user exists
        if (!userToDelete) return { success: false, message: "User not found." };

        // **Safety Check**: Prevent deleting other Registry admins
        if (userToDelete.role === Role.REGISTRY) {
             return { success: false, message: "Cannot delete other Registry administrators." };
        }

        // **Safety Check**: Prevent deleting a Coordinator currently assigned to a center
        if (userToDelete.role === Role.COORDINATOR && userToDelete.coordinatedCenter) {
             return { success: false, message: `Cannot delete Coordinator ${userToDelete.email} as they are assigned to center ${userToDelete.coordinatedCenter.name}. Please change the center's coordinator first.` };
        }

        // If user is a Lecturer, their claims will be cascade deleted by Prisma schema rules.
        // If user is a Coordinator (and not assigned), their processed claims will have processedById set to null.

        // Perform the deletion
        await prisma.user.delete({ where: { id: userId } });

        console.log(`Registry Action: Deleted User ${userToDelete.email} (${userId})`);

        // Revalidate paths
        revalidatePath('/registry/users');
        revalidatePath('/dashboard'); // Stats might change

        return { success: true, message: `User ${userToDelete.email} deleted successfully.` };

    } catch (error) {
        console.error("Delete User Error:", error);
         // Handle specific Prisma errors
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             // Record to delete not found
             return { success: false, message: "User not found. It may have already been deleted." };
         }
        return { success: false, message: "Internal error deleting user." };
    }
}
